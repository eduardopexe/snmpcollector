.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Util 3"
.TH Util 3 "2000-06-27" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
SNMP::Util \- Snmp modules to perform snmp set,get,walk,next,walk_hash etc.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\f(CW\*(C`use SNMP::Util;\*(C'\fR
.PP
## Documentation (\s-1POD\s0)
=head1 \s-1NAME\s0
.PP
.Vb 1
\& Perl SNMP utilities - SNMP::Util - Version 1.8
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This Perl library is a set of utilities for configuring and monitoring \s-1SNMP\s0
based devices.  This library requires the \s-1UCD\s0 port of \s-1SNMP\s0 and the \s-1SNMP\s0.pm
module writted by Joe Marzot.
.SH "Version"
.IX Header "Version"
.Vb 10
\&    1.0 Initial Release
\&    1.1 Fixed Manifest File
\&    1.2 Added get_hash / walk_hash now calls walk / Modified output in poll_value
\&    1.3 Added use strict to library and fixed some bugs with my vars
\&    1.4 Fixed code to elminate perl warning
\&    1.5 Changed all mapInt functions to mapEnum - (support for mapInt not in 
\&        Joe Marzot's version 1.8).
\&    1.6 Updated docs html and text
\&    1.7 Includes patches from Charles Anderson 
\&    1.8 Includes patches from  tyoshida
.Ve
.SH "Software requirements"
.IX Header "Software requirements"
The following applications need to be built and installed before running the 
SNMP::Util application.
.PP
.Vb 2
\&    ucd-snmp-3.5 - ftp:://ftp.ece.ucdavis.edu:/pub/snmp/ucd-snmp.tar.gz
\&    SNMP-1.8 - www.perl.com/CPAN
.Ve
.SH "Summary of functions"
.IX Header "Summary of functions"
.Vb 13
\& get - snmpget and return formatted array
\& get_hash - snmpget and return hash
\& get_set_restore - get value, set new range of values and restore value
\& next - snmpnext and return formatted array
\& ping_check - get uptime and return 1 if reachable
\& ping_check_exit - get uptime and exit if not reachable
\& poll_device - poll a device until it becomes reachable
\& poll_devices - poll several devices until they becomes reachable
\& poll_value - snmpget in a loop until variable reaches desired state
\& set - snmpset and return
\& set_get - snmpset followed by get and check 
\& walk - snmpwalk and return formatted array
\& walk_hash - snmpwalk and return hash ($hash->{mibname}{index} = value)
.Ve
.SH "Creation on the SNMP::Util object"
.IX Header "Creation on the SNMP::Util object"
You must first do a use statement to pull in the library. Then the snmp object can
be created.
.PP
.Vb 3
\& #!/usr/local/lib/perl
\& use lib "put lib path here" 
\& use SNMP::Util;
.Ve
.PP
.Vb 1
\& The SNMP::Util object is created as follows:
.Ve
.PP
.Vb 10
\& $snmp = new SNMP::Util(-device => $IP,
\&                       -community => $community, 
\&                       -timeout => 5,             
\&                       -retry => 0,             
\&                       -poll => 'on',            
\&                       -poll_timeout => 5,        
\&                       -verbose => 'off',         
\&                       -errmode => 'return',    
\&                       -delimiter => ' ', 
\&                      )
.Ve
.PP
.Vb 8
\& community = snmp community string
\& timeout = snmp timeout in seconds (You may also use sub second values ie 0.5)
\& retry = number of snmp retries on timeouts
\& poll = poll the unreachable device after number of retries reached and then retry again
\& poll timeout = poll timeout in minutes default = 5 minutes
\& verbose = controls the output of the snmp low level library
\& errmode = error mode ('return' on error or 'die' on error) default = return
\& delimeter = specifies the character to use between octets when getting octet-strings
.Ve
.PP
.Vb 2
\& Note: Delimiter can also be set by using the setting the Global variable as follows:
\&       $SNMP::Util::Delimiter = '-'
.Ve
.Sh "Creating and using multiple objects"
.IX Subsection "Creating and using multiple objects"
First populate an array of \s-1IP\s0 addresses:
.PP
.Vb 1
\& @IP_array = ('1.1.1.1','1.1.1.2','1.1.1.3','1.1.1.4')
.Ve
.PP
.Vb 1
\& foreach $IP (@IP_array){
.Ve
.PP
.Vb 8
\&    $snmp->{$IP} = new SNMP::Util(-device => $IP,
\&                      -community => $community, 
\&                      -timeout => 5,             
\&                      -retry => 0,               
\&                      -poll => 'on',          
\&                      -delimiter => ' ', 
\&                      )
\& }
.Ve
.PP
.Vb 5
\& #Now get the uptime for each switch
\& foreach $IP (@IP_array){
\&     $uptime = $snmp->{$IP}->get('v','sysUpTime.0')
\&     print "Uptime for $IP = $uptime\en"
\& }
.Ve
.SH "How to use the object for a simple snmpget"
.IX Header "How to use the object for a simple snmpget"
.Vb 3
\&   $uptime = $snmp->get('v','sysUpTime.0')
\&             where 'v', is the format of the output (v = value)
\&             and $uptime contains the system uptime in 10ths of seconds
.Ve
.SH "MIB Loading"
.IX Header "MIB Loading"
The SNMP::Util module loads the mib using the SNMP::Util_env.pm module by using the following statements.
.PP
.Vb 3
\& use SNMP::Util_env
\& # Initialize mib
\& &SNMP::initMib()
.Ve
.PP
.Vb 2
\& You must update the SNMP::Util_env.pm file or simply set up these environment
\& variables and the SNMP::Util_env.pm file will not override them.
.Ve
.PP
.Vb 1
\& The environment variables are as follows:
.Ve
.PP
.Vb 4
\& $ENV{'MIBDIRS'} = '/usr/local/lib/snmp/mibs' 
\& $ENV{'MIBFILES'} = '/ats/data/mibs/rfc1850.mib:
\& /ats/data/mibs/rfc1406.mib:/ats/data/mibs/rfc1407.mib:
\& /ats/data/mibs/rfc1595.mib:/ats/data/mibs/rfc1724.mib'
.Ve
.PP
.Vb 1
\& You can specify whatever MIBS you would like to load.
.Ve
.SH "Error Handling method"
.IX Header "Error Handling method"
All error handling is done through the error handling method (error).
The error message can be obtained by using the method (errmsg)
The detailed error message can be obtained by using the method (errmsg_detail)
.PP
.Vb 1
\& This error method returns a boolean result to indicate if an error ocurred
.Ve
.PP
.Vb 1
\& example:
.Ve
.PP
.Vb 6
\&    if ($snmp->error){
\&        $error = $snmp->errmsg;
\&        $error_detail = $snmp->errmsg_detail;
\&        print "snmp error = $error\en";
\&        print "snmp error detail = $error_detail\en";
\&    }
.Ve
.SH "Print Output Logging"
.IX Header "Print Output Logging"
The printing of output is controlled by the logging routine.  the amount of output is
configured by setting the \s-1MAX_LOG_LEVEL\s0 environment variable.  There are four levels of output logging: (none,status,fail,debug).  You may also set the logging using the global variable Max_log_level.
.PP
.Vb 4
\& none = print  no output (use errmsg only for errors)
\& status = print general status information
\& fail = print general status and failures
\& debug = print general status, failures, and debug information
.Ve
.PP
.Vb 2
\& You can set the environment variable in your environment or inside the 
\& program using the following format:
.Ve
.PP
.Vb 1
\&    $env{'MAX_LOG_LEVEL'} = 'debug'
.Ve
.PP
.Vb 2
\&    or using the global 
\&    $SNMP::Util::Max_log_level = 'debug'
.Ve
.PP
.Vb 1
\& Example Output from Logging:
.Ve
.PP
.Vb 4
\&    get (noSuchName) There is no such variable name in this MIB.
\&    snmpget 100.100.100.1 public 1.3.6.1.2.1.2.2.1.1.1 1.3.6.1.2.1.2.2.1.7.1
\&    snmpget 100.100.100.1 public ifIndex.1 ifAdminStatus.1
\&    snmp error index = 1
.Ve
.PP
.Vb 1
\&    Note: error index = the index of the var bind that failed
.Ve
.SH "Formatting SNMP output (get, next, walk)"
.IX Header "Formatting SNMP output (get, next, walk)"
The \s-1SNMP\s0 utilities have a formatting function which will format the return values 
which are most cases an array.
.PP
.Vb 1
\& The format options are specified as strings as follows:
.Ve
.PP
.Vb 9
\& print " format string = oOnNtvei\en"
\& print " o = oid with index\en"
\& print " O = oid without index\en"
\& print " n = name with index\en"
\& print " N = name without index\en"
\& print " t = type\en"
\& print " v = value\en" 
\& print " e = enumeration\en"
\& print " i = instance of the mib variable\en\en"
.Ve
.PP
.Vb 2
\& Note: enumerations apply to integers and timeticks.  It will convert integer values
\& to enumerations and it will convert timeticks to days,hours,minutes,seconds.
.Ve
.PP
.Vb 1
\& example usage:
.Ve
.PP
.Vb 4
\& @result = $snmp->get('nve','sysUptime.0')
\& $result[0] = sysUptime.0
\& $result[1] = 13392330
\& $result[2] = 1 days, 13:12:03
.Ve
.PP
.Vb 2
\& Note: Any format can be used for the (get,walk,next routines)
\&       Only 'e' or 'v' is needed in the walk_hash routine.
.Ve
.PP
This formatting was designed to allow the user to format the output in
whatever format they need for there application.  You may want to use
the 'v' option when comparing timetick values, but you may want to use 
the 'e' option for the human readable display.
.PP
The snmpget routine may be equated to an array if the formatting has more than
one value or it may be equated to a scalar value if the formatting has only one
value.  It must be equated to an array if the snmpget is a multi var bind.
.SH "Input Formatting"
.IX Header "Input Formatting"
The input supplied to the \s-1SNMP\s0 functions is designed to be very flexible and
allows the user to use shortcuts to apply instances to variables.
.Sh "Input formatting options for the get,next,walk"
.IX Subsection "Input formatting options for the get,next,walk"
\&\fBSimple format name.instance or oid.instance\fR
.PP
.Vb 2
\& $snmp->get('e','ifIndex.1','ifAdminStatus.1','ifOperStatus.1')
\& $snmp->get('e','1.3.6.1.2.1.2.2.1.1.1','1.3.6.1.2.1.2.2.1.7.1','1.3.6.1.2.1.2.2.1.8.1')
.Ve
.PP
\&\fBShortcut format instance up front (no instance in mib name or oid\fR
.PP
.Vb 2
\& $snmp->get('e',1,'ifIndex','ifAdminStatus','ifOperStatus')
\& $snmp->get('e',1,'1.3.6.1.2.1.2.2.1.1','1.3.6.1.2.1.2.2.1.7','1.3.6.1.2.1.2.2.1.8')
.Ve
.PP
\&\fBLong format name,instance,name,instance etc of oid,instance,oid,instance etc\fR
.PP
.Vb 2
\& $snmp->get('e','ifIndex',1,'ifAdminStatus',1,'ifOperStatus',1)
\& $snmp->get('e','1.3.6.1.2.1.2.2.1.1',1,'1.3.6.1.2.1.2.2.1.7',1,'1.3.6.1.2.1.2.2.1.8',1)
.Ve
.PP
You may also set up an array for any of the above formats and pass the array into the
get function as follows:
.PP
.Vb 2
\& @oids = ('ifIndex.1','ifAdminStatus.1','ifOperStatus.1')
\& $snmp->get('e',@oids)
.Ve
.PP
\&\fBHash like format\fR name => instance or oid => instance
.PP
.Vb 9
\& $interface = 1
\& $snmp->get(
\&           'e',
\&           ifIndex => $interface,
\&           ifAdminStatus => $interface,
\&           ifOperStatus => $interface,
\&           ifSpeed => $interface,
\&           )
\& or
.Ve
.PP
.Vb 7
\& $snmp->get(
\&           index => $interface,
\&           ifIndex,
\&           ifAdminStatus,
\&           ifOperStatus,
\&           ifSpeed,
\&           )
.Ve
.PP
\&\fBCalling get with dashed options\fR
.PP
.Vb 15
\& @result = $snmp->get(
\&                     -format => 'ne',
\&                     -oids => [
\&                               ifIndex => $interface,
\&                               ifAdminStatus => $interface,
\&                               ifOperStatus => $interface,
\&                               ifSpeed => $interface,
\&                               ],
\&                    )
\& or 
\& @oids = ('ifIndex.1','ifAdminStatus.1','ifOperStatus.1')
\& @result = $snmp->get(
\&                     -format => 'ne',
\&                     -oids => \e@oids,
\&                     )
.Ve
.PP
Note: When using the dashed option format, you must pass the array by reference as shown 
above.
.Sh "Input formats for the set routine"
.IX Subsection "Input formats for the set routine"
\&\fBSimple format name.instance,value or oid.instance,value\fR
.PP
.Vb 2
\& $snmp->set('ifAdminStatus.1','up')
\& $snmp->set('1.3.6.1.2.1.2.2.1.7.1','up')
.Ve
.PP
\&\fBShortcut format instance up front (no instance in mib name or oid\fR
.PP
.Vb 2
\& $snmp->set(1,'ifAdminStatus','up')
\& $snmp->set(1,'1.3.6.1.2.1.2.2.1.7','up')
.Ve
.PP
\&\fBLong format name,instance,value or oid,instance,value\fR
.PP
.Vb 2
\& $snmp->set('ifAdminStatus',1,'up')
\& $snmp->set('1.3.6.1.2.1.2.2.1.7',1,'up')
.Ve
.PP
You may also set up an array for any of the above formats and pass the array into the
get method as follows:
.PP
.Vb 2
\& @oids = ('ifAdminStatus.1','up')
\& $snmp->set(@oids)
.Ve
.PP
\&\fBHash like format\fR
.PP
.Vb 4
\& $snmp->set(
\&           "ifAdminStatus.$interface" => 'up',
\&           )
\& or
.Ve
.PP
.Vb 4
\& $snmp->set(
\&           index => $interface,
\&           "ifAdminStatus" => 'up',
\&           )
.Ve
.SH "SNMP Method summary"
.IX Header "SNMP Method summary"
.Sh "get"
.IX Subsection "get"
The get will do a snmpget and return an array specified by the format
statement.
.PP
.Vb 3
\& Usage: @result = $snmp->get('ne','ifAdminStatus.1')
\&        $result[0] = ifAdminStatus.1
\&        $result[1] = 'up'
.Ve
.PP
.Vb 2
\&        $result = $snmp->get('e','ifAdminStatus.1')
\&        Note: As shown above, the result is a scalar if only one value is returned
.Ve
.Sh "get_hash"
.IX Subsection "get_hash"
This method will do an snmpget and return a hash.   The format for the hash is
(value = \f(CW$hash\fR\->{mibname}{index}).
.PP
.Vb 2
\& example: $hash = $snmp->get_hash('ne','ifIndex.1','ifIndex.2',
\&                                  'ifOperStatus.1','ifOperStatus.2');
.Ve
.PP
.Vb 4
\& $hash->{ifIndex}{1} = 1
\& $hash->{ifIndex}{2} = 2
\& $hash->{ifOperStatus}{1} = up
\& $hash->{ifOperStatus}{2} = up
.Ve
.PP
.Vb 1
\& Note: Valid format statements for get_hash are 'ne' or 'nv'
.Ve
.Sh "get_set_restore"
.IX Subsection "get_set_restore"
The get_set_restore will get the variable, set it to a range and restore the value
.PP
.Vb 2
\& Usage:  @result = $snmp->get_set_restore('1..10','ifAdminStatus.1');
\&         where the value '1..10' is the range of values
.Ve
.PP
.Vb 1
\& Note: The range is specified using .. for ranges and , for individual values.
.Ve
.Sh "next"
.IX Subsection "next"
The next will do a snmpnext and return an array specified by the format
statement.
.PP
.Vb 3
\& Usage:  @result = $snmp->next('ne','ifAdminStatus.1')
\&        $result[0] = ifAdminStatus.2
\&        $result[1] = 'up'
.Ve
.PP
.Vb 2
\&        $result = $snmp->next('e','ifAdminStatus.1')
\&        Note: As shown above, the result is a scalar if only one value is returned
.Ve
.Sh "ping_check"
.IX Subsection "ping_check"
The ping_check will do a snmpget of uptime and return 1 if device is alive
.Sh "ping_check_exit"
.IX Subsection "ping_check_exit"
The ping_check will do a snmpget of uptime and exit if not alive 
.Sh "poll_device"
.IX Subsection "poll_device"
The poll_device will loop on the snmpget of uptime command until the device is reachable. 
The loop will exit once the poll_timeout time is reached (default = 5 minutes).
.Sh "poll_devices"
.IX Subsection "poll_devices"
The poll_devices will do a snmpget of uptime on several devices until the device are reachable.
The loop will exit once the poll_timeout time is reached (default = 5 minutes).
.PP
.Vb 2
\& $snmp->poll_devices(@IP_array);
\& where @IP_array = array of IP addresses
.Ve
.Sh "poll_value"
.IX Subsection "poll_value"
The poll value method will poll a mib variable until it reaches that state and returns the amount of time it took to reach that state
.PP
.Vb 5
\& Usage: $snmp->poll_value(-oid => "ifAdminStatus.$interface",
\&                         -state => 'up',
\&                         -timeout => 120,
\&                         -montime => 5,
\&                         -delay   => 1)
.Ve
.PP
.Vb 1
\& or
.Ve
.PP
.Vb 6
\& $snmp->poll_value(-oid     => "1.3.6.1.2.1.2.2.1.8",
\&                  -instance => $interface,
\&                  -state => 'up',
\&                  -timeout => 120,
\&                  -montime => 5,
\&                  -delay   => 1)
.Ve
.PP
or  
.PP
.Vb 2
\& use a array ref if you want the polling to stop when the result 
\& matches more than one value
.Ve
.PP
.Vb 6
\& $snmp->poll_value(-oid     => "1.3.6.1.2.1.2.2.1.8",
\&                  -instance => $interface,
\&                  -state => ['up','down']
\&                  -timeout => 120,
\&                  -montime => 5,
\&                  -delay   => 1)
.Ve
.PP
.Vb 1
\& Note: You must use the instance when using oids.
.Ve
.Sh "set"
.IX Subsection "set"
The set will set a group of variables and return 1 if passed
.PP
.Vb 4
\& Usage:  @result = $snmp->set(
\&                             index => 1,
\&                             ifAdminStatus => 'up',
\&                             )
.Ve
.Sh "set_get"
.IX Subsection "set_get"
The set_get will set a group of variables,get,check and return 1 if passed
.PP
.Vb 4
\& Usage:  @result = $snmp->set(
\&                             index => 1,
\&                             ifAdminStatus => 'up',
\&                             )
.Ve
.Sh "walk"
.IX Subsection "walk"
The walk will do a snmpwalk and return an array specified by the format
statement. It also has a special print option to print out each loop in the 
walk. This method is capable of doing multivarbind walks.
.PP
.Vb 3
\& Usage: @result = $snmp->walk(-format => 'ne',
\&                               -oids =>['ifAdminStatus'],
\&                               -print => 'on');
.Ve
.PP
.Vb 1
\&                  where print = 'on' or 'off'
.Ve
.PP
.Vb 1
\&        or use the shortcut format (Note: print will be disabled by default
.Ve
.PP
.Vb 1
\&        @result = $snmp->walk('ne','ifAdminStatus');
.Ve
.PP
.Vb 5
\&        $result[0] = ifAdminStatus.1
\&        $result[1] = 'up'
\&        $result[2] = ifAdminStatus.2
\&        $result[3] = 'up'
\&        ...
.Ve
.Sh "walk_hash"
.IX Subsection "walk_hash"
The walk_hash will do a snmpwalk and return a hash with the value specified by the format.
This method is capable of doing multivarbind walks.
.PP
.Vb 7
\& Usage: $result = $snmp->walk_hash('e','ifIndex','ifAdminStatus','ifOperStatus')
\&        $result->{ifIndex}{1} = 1
\&        $result->{ifAdminStatus}{1} = 'up'
\&        $result->{ifOperStatus}{1} = 'up'
\&        $result->{ifIndex}{2} = 2
\&        $result->{ifAdminStatus}{2} = 'up'
\&        $result->{ifOperStatus}{2} = 'up'
.Ve
.PP
.Vb 8
\& or 
\& Usage: $result = $snmp->walk_hash('v','ifIndex','ifAdminStatus','ifOperStatus')
\&        $result->{ifIndex}{1} = 1
\&        $result->{ifAdminStatus}{1} = 1
\&        $result->{ifOperStatus}{1} = 1
\&        $result->{ifIndex}{2} = 2
\&        $result->{ifAdminStatus}{2} = 1
\&        $result->{ifOperStatus}{2} = 1
.Ve
